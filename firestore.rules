rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    function isSignedIn() {
      return request.auth != null;
    }

    function isNonEmptyString(v) {
      return v is string && v.size() > 0 && v.size() <= 200;
    }

    function isValidEmail(v) {
      return v is string && v.size() > 3 && v.size() <= 320 && v.matches('^.+@.+\\..+$');
    }

    function isValidDepartment(v) {
      return v is string && v.size() > 0 && v.size() <= 100;
    }

    function isValidSalary(v) {
      // Only ensure it's a number. No min/max constraints per product decision.
      return (v is int || v is float);
    }

    function isValidISODate(v) {
      // Expecting YYYY-MM-DD string from the UI date input
      return v is string && v.matches('^\\d{4}-\\d{2}-\\d{2}$');
    }

    function isValidYearMonth(v) {
      // Expecting YYYY-MM from the month input
      return v is string && v.matches('^\\d{4}-\\d{2}$');
    }

    function isTimestamp(v) {
      return v is timestamp;
    }

    // ISO 8601 date-time such as 2025-09-26T12:34:56.789Z
    function isValidISODateTime(v) {
      return v is string && v.matches('^\\d{4}-\\d{2}-\\d{2}T[0-9:.-]+Z$');
    }

    function hasOnlyAllowedKeys(d) {
      // Allow only these keys (others are optional)
      return d.keys().hasOnly([
        'name','email','position','department','salary','joinDate',
        'qid','phone','qidPdfUrl','passportPdfUrl','qidExpiry','passportExpiry',
          'bankName','bankAccountNumber','bankIban','profileImageUrl',
          'nationality'
        ,'terminated','terminatedAt'
      ]);
    }

    function validateEmployee(d) {
      return hasOnlyAllowedKeys(d)
        && isNonEmptyString(d.name)
        && isValidEmail(d.email)
        && isNonEmptyString(d.position)
        && isValidDepartment(d.department)
        && isValidSalary(d.salary)
        && isValidISODate(d.joinDate)
        // Optionals with basic validation
        && (!('qid' in d) || (d.qid is string && d.qid.size() <= 32))
        && (!('phone' in d) || (d.phone is string && d.phone.size() <= 32))
        && (!('qidPdfUrl' in d) || (d.qidPdfUrl is string && d.qidPdfUrl.size() <= 2048))
        && (!('passportPdfUrl' in d) || (d.passportPdfUrl is string && d.passportPdfUrl.size() <= 2048))
    && (!('qidExpiry' in d) || isValidISODate(d.qidExpiry))
    && (!('passportExpiry' in d) || isValidISODate(d.passportExpiry))
        && (!('bankName' in d) || (d.bankName is string && d.bankName.size() <= 200))
        && (!('bankAccountNumber' in d) || (d.bankAccountNumber is string && d.bankAccountNumber.size() <= 40))
        && (!('bankIban' in d) || (d.bankIban is string && d.bankIban.size() <= 40))
  && (!('profileImageUrl' in d) || (d.profileImageUrl is string && d.profileImageUrl.size() <= 2048))
        && (!('nationality' in d) || (d.nationality is string && d.nationality.size() <= 100))
        && (!('terminated' in d) || (d.terminated is bool))
        && (!('terminatedAt' in d) || isTimestamp(d.terminatedAt));
    }

    match /employees/{docId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && validateEmployee(request.resource.data);
      allow update: if isSignedIn() && validateEmployee(request.resource.data);
      allow delete: if isSignedIn();
    }

    // Temporary employees collection with same schema/permissions
    match /temporaryEmployees/{docId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && validateEmployee(request.resource.data);
      allow update: if isSignedIn() && validateEmployee(request.resource.data);
      allow delete: if isSignedIn();
    }

    // Vehicles collection
    function vehiclesAllowedKeys(d) {
      return d.keys().hasOnly([
        'model','brand','year','owner','vehicleNumber','status',
        'expiryDate','renewDate','registrationDate','createdAt','istimaraURL'
      ]);
    }

    function validateVehicle(d) {
      return vehiclesAllowedKeys(d)
        && isNonEmptyString(d.model)
        && isNonEmptyString(d.brand)
        && (d.year is int && d.year >= 1900 && d.year <= 2100)
        && isNonEmptyString(d.owner)
        && isNonEmptyString(d.vehicleNumber)
        && (d.status in ['active','inactive','maintenance'])
        && isValidISODate(d.expiryDate)
        && (!('renewDate' in d) || isValidISODate(d.renewDate))
        && isValidISODate(d.registrationDate)
        && isValidISODateTime(d.createdAt)
        && (!('istimaraURL' in d) || (d.istimaraURL is string && d.istimaraURL.size() <= 2048));
    }

    match /vehicles/{docId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && validateVehicle(request.resource.data);
      allow update: if isSignedIn() && validateVehicle(request.resource.data);
      allow delete: if isSignedIn();
    }

    // Payslips collection: records generated slips with amounts
    function payslipAllowedKeys(d) {
      return d.keys().hasOnly([
        'employeeId','employeeType','employeeName','department','position','qid',
        'period','basic','advance','net','notes','isAdvance',
        'createdAt','createdBy','createdByEmail'
      ]);
    }

    function validatePayslip(d) {
      return payslipAllowedKeys(d)
        && isNonEmptyString(d.employeeId)
        && (d.employeeType in ['Temporary','Permanent'])
        && isNonEmptyString(d.employeeName)
        && (!('department' in d) || d.department is string)
        && (!('position' in d) || d.position is string)
        && (!('qid' in d) || d.qid is string)
        && isValidYearMonth(d.period)
        && (d.basic is int || d.basic is float)
  && (d.advance is int || d.advance is float)
        && (d.net is int || d.net is float)
        && (!('notes' in d) || d.notes is string && d.notes.size() <= 1000)
        && (!('isAdvance' in d) || d.isAdvance is bool)
        && isTimestamp(d.createdAt)
        && (!('createdBy' in d) || d.createdBy is string)
        && (!('createdByEmail' in d) || isValidEmail(d.createdByEmail));
    }

    match /payslips/{docId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && validatePayslip(request.resource.data);
      // Allow deletes for signed-in users (audited by security rules and UI confirmation)
      allow delete: if isSignedIn();
      // Still disallow updates
      allow update: if false;
    }

    // Payments collection: records payments/advances
    function paymentsAllowedKeys(d) {
      return d.keys().hasOnly([
        'employeeId','employeeType','employeeName','department','position','qid',
        'amount','overtime','overtimeHours','method','reference','isAdvance','deductFrom','notes','date',
        'createdAt','createdBy','createdByEmail'
      ]);
    }

    function validatePayment(d) {
      return paymentsAllowedKeys(d)
        && isNonEmptyString(d.employeeId)
        && (d.employeeType in ['Temporary','Permanent'])
        && isNonEmptyString(d.employeeName)
        && (!('department' in d) || d.department is string)
        && (!('position' in d) || d.position is string)
        && (!('qid' in d) || d.qid is string)
        && (d.amount is int || d.amount is float) && d.amount >= 0
  && (!('overtime' in d) || ((d.overtime is int || d.overtime is float) && d.overtime >= 0))
  && (!('overtimeHours' in d) || ((d.overtimeHours is int || d.overtimeHours is float) && d.overtimeHours >= 0))
        && (d.method in ['cash','bank','cheque'])
        && (!('reference' in d) || d.reference is string && d.reference.size() <= 200)
        && (d.isAdvance is bool)
        && (d.deductFrom in ['none','next','installments'])
        && (!('notes' in d) || d.notes is string && d.notes.size() <= 1000)
        && isValidISODate(d.date)
        && isTimestamp(d.createdAt)
        && (!('createdBy' in d) || d.createdBy is string)
        && (!('createdByEmail' in d) || isValidEmail(d.createdByEmail));
    }

    match /payments/{docId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && validatePayment(request.resource.data);
      // Allow deletes so salary rollbacks from Ledger can revert payment entries
      allow delete: if isSignedIn();
      // Still disallow updates to preserve audit integrity
      allow update: if false;
    }

    // Balances collection: denormalized per-employee monthly balances
    function balancesAllowedKeys(d) {
      return d.keys().hasOnly([
        'employeeId','employeeType','employeeName','department','position','qid',
        'month','carryover','basic','advances','payments','balance',
        'updatedAt','updatedBy','updatedByEmail'
      ]);
    }

    function isValidYearMonthStrict(v) { return isValidYearMonth(v); }

    function validateBalance(d) {
      return balancesAllowedKeys(d)
        && isNonEmptyString(d.employeeId)
        && (d.employeeType in ['Temporary','Permanent'])
        && isNonEmptyString(d.employeeName)
        && (!('department' in d) || d.department is string)
        && (!('position' in d) || d.position is string)
        && (!('qid' in d) || d.qid is string)
        && isValidYearMonthStrict(d.month)
  && (!('carryover' in d) || (d.carryover is int || d.carryover is float))
        && (d.basic is int || d.basic is float)
        && (d.advances is int || d.advances is float)
        && (d.payments is int || d.payments is float)
        && (d.balance is int || d.balance is float)
        && isTimestamp(d.updatedAt)
        && (!('updatedBy' in d) || d.updatedBy is string)
        && (!('updatedByEmail' in d) || isValidEmail(d.updatedByEmail));
    }

    match /balances/{docId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && validateBalance(request.resource.data);
      allow update: if isSignedIn() && validateBalance(request.resource.data);
      // Disallow deletes for now
      allow delete: if false;
    }

    // Customers collection used by the web app (no auth required for demo)
    function customersAllowedKeys(d) {
      return d.keys().hasOnly(['name','email','phone','company','address','createdAt','monthly']);
    }

    function validateCustomer(d) {
      return customersAllowedKeys(d)
        && isNonEmptyString(d.name)
        && isValidEmail(d.email)
        && (!('phone' in d) || (d.phone is string && d.phone.size() <= 30))
        && (!('company' in d) || (d.company is string && d.company.size() <= 200))
        && isNonEmptyString(d.address) && (d.address.size() <= 500)
        && (!('monthly' in d) || ((d.monthly is int || d.monthly is float) && d.monthly >= 0))
        && isValidISODateTime(d.createdAt);
    }

    match /customers/{docId} {
      // Open reads so the public site can list customers
      allow read: if true;
      // Allow creating/updating documents that pass validation
      allow create: if validateCustomer(request.resource.data);
      allow update: if validateCustomer(request.resource.data);
      // Allow deletes for signed-in users only
      allow delete: if isSignedIn();
    }

    // Assignments/Placements: link employees to clients for manpower supply
    function assignmentsAllowedKeys(d) {
      return d.keys().hasOnly([
        'employeeId','employeeType','employeeName','department','position','qid',
        'clientId','clientName','clientEmail',
        'startDate','endDate','rate','rateType','notes',
        'createdAt','createdBy','createdByEmail','updatedAt'
      ]);
    }

    function validateAssignment(d) {
      return assignmentsAllowedKeys(d)
        && isNonEmptyString(d.employeeId)
        && (d.employeeType in ['Temporary','Permanent'])
        && isNonEmptyString(d.employeeName)
        && (!('department' in d) || d.department is string)
        && (!('position' in d) || d.position is string)
        && (!('qid' in d) || d.qid is string)
        && isNonEmptyString(d.clientId)
        && isNonEmptyString(d.clientName)
        && (!('clientEmail' in d) || isValidEmail(d.clientEmail))
        && isValidISODate(d.startDate)
        && (!('endDate' in d) || isValidISODate(d.endDate))
        && (!('endDate' in d) || d.endDate >= d.startDate)
        && (!('rate' in d) || (d.rate is int || d.rate is float) && d.rate >= 0)
        && (!('rateType' in d) || (d.rateType in ['hourly','daily','monthly']))
        && (!('notes' in d) || (d.notes is string && d.notes.size() <= 1000))
        && isTimestamp(d.createdAt)
        && (!('createdBy' in d) || d.createdBy is string)
        && (!('createdByEmail' in d) || isValidEmail(d.createdByEmail))
        && (!('updatedAt' in d) || isTimestamp(d.updatedAt));
    }

    match /assignments/{docId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && validateAssignment(request.resource.data);
      allow update: if isSignedIn() && validateAssignment(request.resource.data);
      // No deletes for safety
      allow delete: if false;
    }

    // Accounts (Chart of Accounts)
    function accountsAllowedKeys(d) {
      return d.keys().hasOnly(['name','type','opening','createdAt']);
    }
    function validateAccount(d) {
      return accountsAllowedKeys(d)
        && isNonEmptyString(d.name)
        && (d.type in ['Asset','Liability','Equity','Income','Expense'])
        && ((d.opening is int || d.opening is float))
        && isValidISODateTime(d.createdAt);
    }
    match /accounts/{docId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && validateAccount(request.resource.data);
      allow update: if false;
      allow delete: if false;
    }

    // Cashflows: simple cash in/out transactions
    function cashflowAllowedKeys(d) {
      return d.keys().hasOnly(['date','type','accountId','accountName','amount','category','notes','createdAt','updatedAt','createdBy','createdByEmail','clientId','month','payslipId','driverId']);
    }
    function validateCashflow(d) {
      return cashflowAllowedKeys(d)
        && isValidISODate(d.date)
        && (d.type in ['in','out'])
        && isNonEmptyString(d.accountId)
        && (!('accountName' in d) || (d.accountName is string && d.accountName.size() <= 200))
        && ((d.amount is int || d.amount is float) && d.amount > 0)
        && (!('category' in d) || (d.category is string && d.category.size() <= 200))
        && (!('notes' in d) || (d.notes is string && d.notes.size() <= 1000))
        && isValidISODateTime(d.createdAt)
        && (!('updatedAt' in d) || isValidISODateTime(d.updatedAt))
        && (!('createdBy' in d) || d.createdBy is string)
        && (!('createdByEmail' in d) || isValidEmail(d.createdByEmail))
        && (!('clientId' in d) || isNonEmptyString(d.clientId))
        && (!('month' in d) || isValidYearMonth(d.month))
          && (!('payslipId' in d) || (d.payslipId is string && d.payslipId.size() > 0 && d.payslipId.size() <= 200))
          && (!('driverId' in d) || (d.driverId is string && d.driverId.size() > 0 && d.driverId.size() <= 200));
    }
    match /cashflows/{docId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && validateCashflow(request.resource.data);
      allow update: if isSignedIn() && validateCashflow(request.resource.data);
      // Allow deletes for signed-in users (UI prompts for confirmation)
      allow delete: if isSignedIn();
    }

    // Client Transactions: append-only history of grid edits & payments (non-cash meta log)
    function clientTransactionAllowedKeys(d) {
      return d.keys().hasOnly([
        'clientId','month','date','field','value','prevValue',
        'monthly','debited','credited','outstanding','notes','snapshot',
        'createdAt','createdBy','createdByEmail'
      ]);
    }
    function validateClientTransaction(d) {
      return clientTransactionAllowedKeys(d)
        && isNonEmptyString(d.clientId)
        && isValidYearMonth(d.month)
        && isValidISODate(d.date)
        && isValidISODateTime(d.createdAt)
  && (!('field' in d) || (d.field in ['monthly','debited','credited','notes','payment','newRow']))
        && (!('value' in d) || ((d.value is int || d.value is float || d.value is string)))
        && (!('prevValue' in d) || ((d.prevValue is int || d.prevValue is float || d.prevValue is string)))
        && (!('monthly' in d) || (d.monthly is int || d.monthly is float))
        && (!('debited' in d) || (d.debited is int || d.debited is float))
        && (!('credited' in d) || (d.credited is int || d.credited is float))
        && (!('outstanding' in d) || (d.outstanding is int || d.outstanding is float))
        && (!('notes' in d) || (d.notes is string && d.notes.size() <= 1000))
        && (!('snapshot' in d) || (
              d.snapshot is map
              && d.snapshot.keys().hasOnly(['monthly','debited','credited','outstanding','notes'])
              && (!('monthly' in d.snapshot) || (d.snapshot.monthly is int || d.snapshot.monthly is float))
              && (!('debited' in d.snapshot) || (d.snapshot.debited is int || d.snapshot.debited is float))
              && (!('credited' in d.snapshot) || (d.snapshot.credited is int || d.snapshot.credited is float))
              && (!('outstanding' in d.snapshot) || (d.snapshot.outstanding is int || d.snapshot.outstanding is float))
              && (!('notes' in d.snapshot) || (d.snapshot.notes is string && d.snapshot.notes.size() <= 1000))
           ))
        && (!('createdBy' in d) || d.createdBy is string)
        && (!('createdByEmail' in d) || isValidEmail(d.createdByEmail));
    }
    match /clientTransactions/{docId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && validateClientTransaction(request.resource.data);
      allow update, delete: if false;
    }

    // Stats: holds deterministic fund opening/value summary
    function fundAllowedKeys(d) {
      // Allow legacy fields and new balance-based model fields
      return d.keys().hasOnly(['opening','value','balance','inSum','outSum','asOf','setBy','setByEmail','setReason','migratedFromOpening','migratedFromValue']);
    }
    function validateFund(d) {
      return fundAllowedKeys(d)
        // At least one of opening, value, or balance must exist and be numeric
        && ( ('balance' in d && (d.balance is int || d.balance is float))
             || ('opening' in d && (d.opening is int || d.opening is float))
             || ('value' in d && (d.value is int || d.value is float)) )
        && (!('opening' in d) || (d.opening is int || d.opening is float))
        && (!('value' in d) || (d.value is int || d.value is float))
        && (!('balance' in d) || (d.balance is int || d.balance is float))
        && (!('inSum' in d) || (d.inSum is int || d.inSum is float))
        && (!('outSum' in d) || (d.outSum is int || d.outSum is float))
        && isValidISODateTime(d.asOf)
        && (!('setBy' in d) || d.setBy is string)
        && (!('setByEmail' in d) || isValidEmail(d.setByEmail))
        && (!('setReason' in d) || (d.setReason is string && d.setReason.size() <= 200));
    }
    match /stats/{docId} {
      // Allow authenticated users to read stats documents
      allow read: if isSignedIn();
      // Allow creating/updating the fund doc with strict validation
      allow create, update: if isSignedIn() && docId == 'fund' && validateFund(request.resource.data);
      allow delete: if false;
    }

    // Everything else is denied by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
